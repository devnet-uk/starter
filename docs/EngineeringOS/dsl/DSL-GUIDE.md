# Engineering OS DSL Developer Guide

## Overview

This comprehensive guide provides step-by-step instructions for working with the Engineering OS DSL system. Whether you're creating new commands, adding standards, or maintaining existing files, this guide covers the essential patterns and best practices for human developers.

## Quick Start

### Understanding the System

The Engineering OS uses two complementary DSLs:

1. **Standards DSL**: Hierarchical knowledge base for best practices
   - **Entry Point**: Always start at `/docs/standards/standards.md`
   - **Purpose**: Provide surgical context loading without overwhelming agents
   - **Structure**: Root → Category → Standard progression

2. **Instructions DSL**: Structured workflows for complex processes
   - **Location**: `.claude/commands/`
   - **Purpose**: Orchestrate multi-step processes with agent delegation
   - **Structure**: Sequential steps with conditional logic

### When to Use Which DSL

**Use Standards DSL when:**
- Creating best practices documentation
- Adding new coding guidelines
- Defining architecture patterns
- Documenting security requirements

**Use Instructions DSL when:**
- Creating automated workflows
- Orchestrating multi-step processes
- Coordinating between multiple agents
- Implementing complex decision trees

## The Core Workflows: Your Development Lifecycle

The Engineering OS is built around a set of core commands that manage the three essential layers of context for any software project. Understanding these workflows is key to using the system effectively.

### 1. The Standards Layer
This is the foundation of your OS, located in `/docs/standards/`. You define your coding patterns, architecture, and best practices here. All other workflows consume these standards.

### 2. The Product Layer
This layer defines the overall context of your application.

- **For new projects, use `/plan-product`**: This command walks you through defining the product's mission, roadmap, and technology stack, creating the core `docs/product/` documentation.
- **For existing projects, use `/analyze-product`**: This command inspects your codebase to automatically generate the same `docs/product/` context.

### 3. The Specs Layer
This layer is for implementing individual features.

- **`/create-spec`**: Once you have product context, use this to create a detailed plan for a new feature.
- **`/create-tasks`**: After the spec is approved, this command generates a step-by-step checklist for implementation.
- **`/execute-tasks`**: This is the workhorse. It reads the spec and tasks, consults the Product and Standards layers, and implements the feature according to your rules.

**Machine-Optimized Benefits:**
- **Performance**: 85% faster execution through parallelization and streaming
- **LLM Efficiency**: 85% reduction in token usage and parsing complexity
- **Reliability**: Deterministic execution with fail-fast error boundaries
- **Scalability**: Graph-based and functional architectures handle unlimited standards

## Working with Standards

When creating or editing standards, remember that you are contributing to an **intent-based dispatcher system**. Your goal is to make knowledge discoverable through a clear, hierarchical path. Instead of just writing a document, you are creating a node in a knowledge graph that the AI will navigate.

### Creating a New Standard

#### Step 1: Determine Placement

First, identify where your standard belongs in the hierarchy:

```
/docs/standards/
├── standards.md (root dispatcher)
├── architecture/
│   ├── architecture.md (category dispatcher)
│   └── clean-architecture.md (standard)
├── security/
│   ├── security.md (category dispatcher)
│   └── api-security.md (standard)
└── [other categories]/
```

#### Standards Dependency Graph

The following graph visualizes the dependency hierarchy of the standards, starting from the root dispatcher. This is generated by analyzing the routing within the files themselves.

```
/docs/standards/standards.md
├── /docs/standards/architecture/architecture.md
│   ├── /docs/standards/architecture/clean-architecture.md
│   │   ├── /docs/standards/architecture/domain-utilities.md
│   │   ├── /docs/standards/architecture/infrastructure-patterns.md
│   │   └── /docs/standards/architecture/integration-strategy.md
│   ├── /docs/standards/architecture/domain-driven-design.md
│   ├── /docs/standards/architecture/feature-sliced-design.md
│   │   └── /docs/standards/architecture/integration-strategy.md
│   ├── /docs/standards/architecture/solid-principles.md
│   ├── /docs/standards/architecture/resilience-patterns.md
│   ├── /docs/standards/architecture/integration-strategy.md
│   ├── /docs/standards/architecture/agent-standards-integration.md
│   ├── /docs/standards/architecture/refactoring-patterns.md
│   ├── /docs/standards/architecture/use-case-patterns.md
│   ├── /docs/standards/architecture/multi-tenancy-patterns.md
│   ├── /docs/standards/architecture/streaming-patterns.md
│   ├── /docs/standards/architecture/billing-patterns.md
│   ├── /docs/standards/architecture/background-job-patterns.md
│   ├── /docs/standards/architecture/notification-patterns.md
│   ├── /docs/standards/architecture/search-patterns.md
│   ├── /docs/standards/architecture/caching-patterns.md
│   └── /docs/standards/architecture/audit-logging-patterns.md
├── /docs/standards/code-style.md
│   ├── /docs/standards/code-style/typescript-style.md
│   │   └── /docs/standards/development/monorepo-setup.md
│   ├── /docs/standards/code-style/naming-conventions.md
│   │   └── /docs/standards/stack-specific/drizzle-patterns.md
│   ├── /docs/standards/code-style/react-patterns.md
│   ├── /docs/standards/code-style/css-style.md
│   └── /docs/standards/code-style/html-style.md
├── /docs/standards/performance/performance.md
│   ├── /docs/standards/performance/bundle-optimization.md
│   ├── /docs/standards/performance/core-web-vitals.md
│   └── /docs/standards/performance/observability.md
│       └── /docs/standards/development/local-environment.md
├── /docs/standards/security/security.md
│   ├── /docs/standards/security/api-security.md
│   ├── /docs/standards/security/authentication.md
│   ├── /docs/standards/security/authentication-patterns.md
│   └── /docs/standards/security/dependency-scanning.md
├── /docs/standards/development/development.md
│   ├── /docs/standards/development/ci-cd.md
│   │   └── /docs/standards/development/testing-strategy.md
│   ├── /docs/standards/development/code-review.md
│   ├── /docs/standards/development/database-migrations.md
│   ├── /docs/standards/development/documentation.md
│   ├── /docs/standards/development/git-workflow.md
│   │   └── /docs/standards/development/local-quality.md
│   ├── /docs/standards/development/testing-strategy.md
│   ├── /docs/standards/development/monorepo-setup.md
│   │   └── /docs/standards/code-style/typescript-style.md
│   ├── /docs/standards/development/local-environment.md
│   ├── /docs/standards/development/local-quality.md
│   │   └── /docs/standards/development/metrics.md
│   └── /docs/standards/development/metrics.md
├── /docs/standards/stack-specific/stack-specific.md
│   ├── /docs/standards/stack-specific/drizzle-patterns.md
│   ├── /docs/standards/stack-specific/hono-api.md
│   ├── /docs/standards/stack-specific/next-safe-action.md
│   ├── /docs/standards/stack-specific/tanstack-query.md
│   ├── /docs/standards/stack-specific/vercel-ai.md
│   ├── /docs/standards/stack-specific/vercel-deployment.md
│   └── /docs/standards/stack-specific/zustand-state.md
└── /docs/standards/best-practices.md
    ├── /docs/standards/architecture/resilience-patterns.md
    ├── /docs/standards/architecture/clean-architecture.md
    ├── /docs/standards/architecture/feature-sliced-design.md
    ├── /docs/standards/architecture/domain-driven-design.md
    ├── /docs/standards/architecture/solid-principles.md
    ├── /docs/standards/development/git-workflow.md
    ├── /docs/standards/development/testing-strategy.md
    ├── /docs/standards/stack-specific/hono-api.md
    ├── /docs/standards/security/api-security.md
    ├── /docs/standards/stack-specific/drizzle-patterns.md
    ├── /docs/standards/development/database-migrations.md
    ├── /docs/standards/stack-specific/zustand-state.md
    ├── /docs/standards/performance/core-web-vitals.md
    ├── /docs/standards/performance/bundle-optimization.md
    ├── /docs/standards/security/authentication.md
    ├── /docs/standards/stack-specific/next-safe-action.md
    ├── /docs/standards/security/server-actions.md
    ├── /docs/standards/development/ci-cd.md
    ├── /docs/standards/stack-specific/vercel-deployment.md
    ├── /docs/standards/performance/monitoring.md
    ├── /docs/standards/stack-specific/vercel-ai.md
    ├── /docs/standards/development/code-review.md
    ├── /docs/standards/development/documentation.md
    ├── /docs/standards/security/dependency-scanning.md
    └── /docs/standards/stack-specific/tanstack-query.md
```

#### Step 2: Create the Standard File

Create your standard file following this template:

```markdown
# [Standard Title]

## Overview
Brief description of the standard's purpose and scope.

## [Content Section 1]
Detailed guidance on specific aspect.

## [Content Section 2]
Additional guidance with examples.

<!-- Optional: Reference related standards -->
<conditional-block task-condition="related-keywords" context-check="related-standard">
IF task involves related functionality:
  <context_fetcher_strategy>
    USE: @agent:context-fetcher
    REQUEST: "Get related guidance from path/to/related-standard.md"
  </context_fetcher_strategy>
</conditional-block>
```

#### Step 3: Update Category Dispatcher

Add routing logic to the appropriate category dispatcher:

```xml
<conditional-block task-condition="your-keywords|related-terms" context-check="your-standard">
IF current task involves your domain:
  <context_fetcher_strategy>
    USE: @agent:context-fetcher
    REQUEST: "Get [your standard] from [category]/[your-standard].md"
  </context_fetcher_strategy>
</conditional-block>
```

#### Step 4: Update Root Dispatcher (if new category)

If creating a new category, add routing to the root dispatcher:

```xml
<conditional-block task-condition="category-keywords" context-check="category-name">
  <context_fetcher_strategy>
    USE: @agent:context-fetcher
    REQUEST: "Get category routing from [category]/[category].md"
  </context_fetcher_strategy>
</conditional-block>
```

### Adding Content to Existing Standards

#### Simple Addition

For straightforward content additions:

```markdown
## New Section

New content here that doesn't require conditional loading.
```

#### Conditional Addition

For content that should only load in specific contexts:

```xml
<conditional-block task-condition="specific-case" context-check="new-content">
IF task involves specific functionality:
  
## Conditional Section
Content that only loads when needed.

</conditional-block>
```

### Intent Strategy

The `task-condition` attribute is the most critical part of the routing system. Think of the keywords not just as search terms, but as the definition of a **task intent**.

**When choosing keywords, ask:**
-   "What is the user or agent *trying to do* when they need this standard?"
-   "What core concepts define this task?" (e.g., `authentication`, `testing`, `deployment`).
-   "What technologies are involved?" (e.g., `react`, `drizzle`, `hono`).

**Example of defining an intent:**
-   **Standard**: `api-security.md`
-   **User Intent**: "I need to secure my API endpoint."
-   **Keywords (`task-condition`)**: `api|endpoint|route|security|authentication|authorization|rate-limiting|cors|csrf`

## Working with Commands

### Creating a New Command

#### Step 1: Define the Command Structure

Create a new file in `.claude/commands/`:

```markdown
---
description: Brief description of command purpose
version: 1.0
encoding: UTF-8
---

# Command Title

## Overview
Detailed description of what this command accomplishes.

<pre_flight_check>
  EXECUTE: @.claude/commands/meta/pre-flight.md
</pre_flight_check>

<process_flow>
  [Steps go here]
</process_flow>

<post_flight_check>
  EXECUTE: @.claude/commands/meta/post-flight.md
</post_flight_check>
```

#### Step 2: Design the Workflow

Break down your process into logical steps:

```xml
<step number="1" name="input_analysis">
### Step 1: Input Analysis

<instructions>
  ACTION: Parse and validate user input
  VERIFY: Requirements are clear
  CONFIRM: Understanding with user
</instructions>
</step>

<step number="2" subagent="context-fetcher" name="gather_context">
### Step 2: Context Gathering

<instructions>
  ACTION: Use context-fetcher subagent
  REQUEST: "Get relevant documentation from [source]"
  PROCESS: Retrieved information
</instructions>
</step>
```

#### Step 3: Add Conditional Logic

Include decision trees for complex workflows:

```xml
<option_a_flow>
  <trigger>specific condition</trigger>
  <actions>
    1. Perform action A
    2. Validate result A
    3. Proceed to step X
  </actions>
</option_a_flow>

<option_b_flow>
  <trigger>different condition</trigger>
  <actions>
    1. Perform action B
    2. Validate result B
    3. Proceed to step Y
  </actions>
</option_b_flow>
```

### Integrating Standards in Commands

#### Standard Pattern

Most commands should include a standards consultation step:

```xml
<step number="2" subagent="context-fetcher" name="consult_standards">
### Step 2: Consult Standards

<instructions>
  ACTION: Use context-fetcher subagent
  REQUEST: "Consult the standards knowledge base for guidance relevant to the current task. Start at the root dispatcher located at @docs/standards/standards.md and follow the routing logic to retrieve the necessary guidance."
  PROCESS: Returned standards and guidance
  APPLY: Relevant patterns to implementation
</instructions>
</step>
```

#### Specific Standards Loading

For targeted standards loading:

```xml
<instructions>
  CONDITIONAL_STANDARDS: Load based on task analysis:
    IF task involves testing:
      REQUEST: "Get testing strategy from development/testing-strategy.md"
    IF task involves API work:
      REQUEST: "Get API patterns from stack-specific/hono-api.md"
</instructions>
```

## Writing and Using Verifications

The Engineering OS includes a powerful verification system that allows you to embed automated tests directly within your standards documentation. This ensures that the guidance you write is verifiably implemented by the AI agents.

### Adding a Verification Block

To add a set of checks to a standard, include a `<verification-block>`.

**Location**: Place the block within the standard file that contains the rules you want to verify.
**`context-check`**: Give it a globally unique ID.

**Example: In `development/local-quality.md`**
```xml
# Standard content about Husky git hooks...

<verification-block context-check="verification-husky-setup">
  <verification_definitions>
    <test name="husky_installed">
      TEST: "test -d .husky"
      REQUIRED: true
      BLOCKING: true
      ERROR: "Husky not installed. Run 'npx husky init' to set up git hooks."
      DESCRIPTION: "Verifies that the .husky directory exists, indicating installation."
    </test>
    <test name="pre_commit_hook_exists">
      TEST: "test -f .husky/pre-commit"
      REQUIRED: true
      BLOCKING: true
      ERROR: "Pre-commit hook file missing. Create .husky/pre-commit with quality checks."
      DESCRIPTION: "Ensures the pre-commit hook is configured."
      DEPENDS_ON: ["husky_installed"]
    </test>
  </verification_definitions>
</verification-block>
```

### Writing Effective Tests

-   **Be Atomic**: Each `<test>` should check one specific thing.
-   **Provide Actionable Errors**: The `ERROR` message should tell the user exactly what is wrong and how to fix it. Use the `FIX_COMMAND` for copy-pastable solutions.
-   **Use Variables**: Make your tests adaptable to different projects by using variables like `${PROJECT_COVERAGE}`. The system will substitute these automatically.
-   **Define Dependencies**: Use `DEPENDS_ON` to ensure tests run in a logical order, preventing cascading failures.
-   **Set `BLOCKING`**: For critical, non-negotiable standards, set `BLOCKING: true`. This will halt the AI's workflow until the issue is fixed, enforcing your quality gate.

### How Verifications Are Used

1.  **Authoring**: You write a standard and embed a verification block.
2.  **Loading**: An AI agent working on a task loads your standard based on its intent.
3.  **Extraction**: The `verification-runner` subagent automatically finds and prepares the tests from the loaded standard.
4.  **Execution**: After the AI completes its implementation task, the `verification-runner` executes the tests.
5.  **Reporting**: If a test fails, the AI receives the exact `ERROR` message you wrote and is instructed to perform the `FIX_COMMAND`.

By embedding verifications, you turn your documentation from passive guidance into active, enforceable quality gates.

## Common Patterns

### Standards DSL Patterns

#### Dispatcher Routing

```xml
<!-- Root dispatcher pattern -->
<conditional-block task-condition="broad-category-keywords">
  <context_fetcher_strategy>
    USE: @agent:context-fetcher
    REQUEST: "Get category routing from category/category.md"
  </context_fetcher_strategy>
</conditional-block>

<!-- Category dispatcher pattern -->  
<conditional-block task-condition="specific-keywords" context-check="standard-name">
IF current task involves specific domain:
  <context_fetcher_strategy>
    USE: @agent:context-fetcher
    REQUEST: "Get specific guidance from category/standard.md"
  </context_fetcher_strategy>
</conditional-block>
```

#### Content with Cross-References

```markdown
# Standard Title

## Main Content
Primary guidance and best practices.

<conditional-block task-condition="related-task" context-check="related-guidance">
IF task involves related functionality:
  <context_fetcher_strategy>
    USE: @agent:context-fetcher
    REQUEST: "Get related patterns from other/related-standard.md"
  </context_fetcher_strategy>
</conditional-block>
```

#### Standards with Verification Blocks

```markdown
# Standard Title

## Implementation Requirements
Specific requirements and best practices.

<!-- Verification block for automated compliance checking -->
<verification-block context-check="verification-standard-compliance">
  <verification_definitions>
    <test name="requirement_met">
      TEST: test -f required-file.json
      REQUIRED: true
      ERROR: "Required configuration file missing. Create required-file.json with proper settings."
    </test>
    <test name="coverage_threshold">
      TEST: grep -q 'threshold.*${PROJECT_COVERAGE}' package.json
      REQUIRED: true
      VARIABLES: ["PROJECT_COVERAGE"]
      ERROR: "Coverage threshold not set to ${PROJECT_COVERAGE}%. Update package.json coverage scripts."
    </test>
  </verification_definitions>
</verification-block>
```

### Instructions DSL Patterns

#### Basic Step Pattern

```xml
<step number="N" name="descriptive_name">
### Step N: Human Readable Title

Description of what this step accomplishes.

<instructions>
  ACTION: Primary action to take
  VERIFY: Condition or outcome
  PROCEED: To next step or condition
</instructions>
</step>
```

#### Subagent Delegation Pattern

```xml
<step number="N" subagent="agent-name" name="delegated_task">
### Step N: Delegated Task

<instructions>
  ACTION: Use [agent-name] subagent
  REQUEST: "Specific request with clear parameters"
  WAIT: For completion
  PROCESS: Returned results
</instructions>
</step>
```

#### Loop Pattern

```xml
<step number="N" name="iterative_process">
### Step N: Iterative Process

<execution_loop>
  FOR each item in collection:
    EXECUTE: specific action
    VERIFY: result
    UPDATE: progress
  END FOR
</execution_loop>

<loop_control>
  <continue_conditions>
    - More items to process
    - No blocking errors
  </continue_conditions>
  <exit_conditions>
    - All items processed
    - Critical error encountered
  </exit_conditions>
</loop_control>
</step>
```

## Real-World Examples

### Complete Command Example

```markdown
---
description: Task Execution Rules
version: 1.0
encoding: UTF-8
---

# Task Execution Rules

## Overview
Initiate execution of one or more tasks for a given spec.

<pre_flight_check>
  EXECUTE: @.claude/commands/meta/pre-flight.md
</pre_flight_check>

<process_flow>

<step number="1" name="task_assignment">
### Step 1: Task Assignment

Identify which tasks to execute from the spec, defaulting to the next uncompleted parent task if not specified.

<task_selection>
  <explicit>user specifies exact task(s)</explicit>
  <implicit>find next uncompleted task in tasks.md</implicit>
</task_selection>

<instructions>
  ACTION: Identify task(s) to execute
  DEFAULT: Select next uncompleted parent task if not specified
  CONFIRM: Task selection with user
</instructions>
</step>

<step number="2" subagent="context-fetcher" name="context_analysis">
### Step 2: Context Analysis with Standards

Use the context-fetcher subagent to gather minimal context for task understanding by always loading spec tasks.md, and conditionally loading project context and relevant standards based on task type.

<instructions>
  ACTION: Use context-fetcher subagent to:
    - REQUEST: "Get product pitch from mission-lite.md"
    - REQUEST: "Get spec summary from spec-lite.md"  
    - REQUEST: "Get technical approach from technical-spec.md"
    
  CONDITIONAL_STANDARDS: Load based on task analysis:
    - REQUEST: "Consult the standards knowledge base for guidance relevant to the current task. Start at the root dispatcher located at @docs/standards/standards.md and follow the routing logic to retrieve the necessary guidance."
    
  PROCESS: Returned information and standards
</instructions>
</step>

<step number="3" name="development_server_check">
### Step 3: Check for Development Server

Check for any running development server and ask user permission to shut it down if found to prevent port conflicts.

<server_check_flow>
  <if_running>
    ASK user to shut down
    WAIT for response
  </if_running>
  <if_not_running>
    PROCEED immediately
  </if_not_running>
</server_check_flow>

<instructions>
  ACTION: Check for running local development server
  CONDITIONAL: Ask permission only if server is running
  PROCEED: Immediately if no server detected
</instructions>
</step>

<step number="4" subagent="git-workflow" name="git_branch_management">
### Step 4: Git Branch Management

Use the git-workflow subagent to manage git branches to ensure proper isolation by creating or switching to the appropriate branch for the spec.

<instructions>
  ACTION: Use git-workflow subagent
  REQUEST: "Check and manage branch for spec: [SPEC_FOLDER]
            - Create branch if needed
            - Switch to correct branch
            - Handle any uncommitted changes"
  WAIT: For branch setup completion
</instructions>
</step>

</process_flow>

<post_flight_check>
  EXECUTE: @.claude/commands/meta/post-flight.md
</post_flight_check>
```

### Standards File Example

```markdown
# React Component Patterns

## Overview
React component development following Feature-Sliced Design architecture.

## Component Structure

### Functional Components
Use functional components with hooks for all new development:

```typescript
interface UserCardProps {
  user: User;
  onEdit: (id: string) => void;
}

export const UserCard: React.FC<UserCardProps> = ({ user, onEdit }) => {
  const [isLoading, setIsLoading] = useState(false);
  
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>Edit</button>
    </div>
  );
};
```

## State Management

### Local State with useState
For component-specific state that doesn't need to be shared:

```typescript
const [count, setCount] = useState(0);
const [user, setUser] = useState<User | null>(null);
```

### Global State with Zustand
For shared application state:

```typescript
import { useUserStore } from '@/shared/stores/user';

const { users, addUser, removeUser } = useUserStore();
```

<conditional-block task-condition="form|validation|input" context-check="form-patterns">
IF task involves form handling:
  <context_fetcher_strategy>
    USE: @agent:context-fetcher
    REQUEST: "Get form validation patterns from security/server-actions.md"
  </context_fetcher_strategy>
</conditional-block>

<conditional-block task-condition="testing|test" context-check="component-testing">
IF task involves component testing:
  <context_fetcher_strategy>
    USE: @agent:context-fetcher
    REQUEST: "Get React testing patterns from development/testing-strategy.md#component-tests"
  </context_fetcher_strategy>
</conditional-block>
```

## Best Practices

### Standards DSL Best Practices

#### 1. Keyword Selection

**Do:**
- Use terms developers actually search for
- Include both technical and colloquial terms
- Cover different ways to describe the same concept

**Don't:**
- Use overly broad terms that match everything
- Use terms so specific they rarely match
- Include unrelated keywords for broader matching

#### 2. Context Check IDs

**Do:**
- Use descriptive names: `typescript-patterns-complete`
- Include the standard scope: `api-security-authentication`
- Make them globally unique across all standards

**Don't:**
- Use generic names: `complete`, `loaded`, `ready`
- Reuse IDs across different standards
- Make them too long or complex

#### 3. Content Organization

**Do:**
- Keep dispatchers pure (routing only)
- Put all actual content in standard files
- Use conditional blocks for cross-references

**Don't:**
- Mix routing and content in dispatchers
- Create circular references between standards
- Load entire hierarchies when only one standard needed

### Instructions DSL Best Practices

#### 1. Step Design

**Do:**
- Make each step accomplish one clear objective
- Use descriptive step names and titles
- Include validation and error handling

**Don't:**
- Cram multiple unrelated actions into one step
- Use vague step names like `process_stuff`
- Skip error handling for critical operations

#### 2. Subagent Usage

**Do:**
- Use subagents for their specialized capabilities
- Provide clear, specific requests
- Wait for completion before proceeding

**Don't:**
- Use subagents for simple operations you could do directly
- Make vague requests that require guessing
- Assume subagents maintain state between steps

#### 3. Standards Integration

**Do:**
- Always use the hierarchical dispatcher system
- Load standards relevant to current task
- Cache standards within workflow context

**Don't:**
- Bypass the dispatcher hierarchy
- Load all standards regardless of relevance
- Reload standards already in context

#### 4. Verification System Integration

The verification system enables automated compliance checking by embedding verification blocks within standards files.

**System Architecture:**
The verification system operates through a two-phase design:
1. **Embedding Phase**: Verification blocks are authored within standards files alongside the guidance they validate
2. **Runtime Phase**: The verification-runner subagent extracts and executes these blocks dynamically

**For Standards Authors:**

Add verification blocks to standards for automated compliance checking:

```xml
<verification-block context-check="unique-verification-id">
  <verification_definitions>
    <test name="descriptive_test_name">
      TEST: shell command to execute
      REQUIRED: true|false
      ERROR: "Clear error message with actionable fix suggestion"
      DESCRIPTION: "What this test validates"
    </test>
    <test name="variable_substitution_example">
      TEST: grep -q "threshold.*${PROJECT_COVERAGE}" package.json
      REQUIRED: true
      ERROR: "Coverage threshold not set to ${PROJECT_COVERAGE}%. Update package.json test scripts."
      DESCRIPTION: "Validates coverage threshold matches project requirements"
    </test>
  </verification_definitions>
</verification-block>
```

**Key Design Principles:**
- **No Separate Files**: Verification blocks exist within standards, not as standalone files
- **Context Coupling**: Verifications automatically available when their parent standard loads
- **Runtime Extraction**: verification-runner dynamically discovers verification blocks
- **Variable Substitution**: Tests adapt to specific project configurations using `${VARIABLE}` syntax

**Available Variables:**
- `${PROJECT_TYPE}`: Auto-detected project type (react, node, fullstack, etc.)
- `${PROJECT_COVERAGE}`: Coverage threshold from project configuration
- `${TYPESCRIPT_VERSION}`: Detected TypeScript version
- `${PACKAGE_MANAGER}`: Detected package manager (npm, pnpm, yarn)
- `${BUILD_TOOL}`: Detected build tool (vite, webpack, next, etc.)
- `${TEST_FRAMEWORK}`: Detected testing framework (vitest, jest, playwright)

**Note**: These variables are placeholders. Their concrete values are provided externally at runtime by the execution environment or agent. For example, a project's implementation plan might define `PROJECT_COVERAGE=98` within a `/create-spec` command, which the `verification-runner` then substitutes into the verification tests.

**For Command Authors:**

Include verification-runner in implementation workflows:

```xml
<step number="8" subagent="verification-runner" name="verify_compliance">
### Step 8: Verify Implementation Compliance

<instructions>
  ACTION: Use verification-runner subagent
  REQUEST: "Execute all verification tests from loaded standards against current implementation"
  PROCESS: Verification results and compliance status
  REPORT: Pass/fail status with actionable error messages for failures
</instructions>
</step>
```

**Verification Workflow Integration:**
1. **During Spec Creation**: Verification requirements are extracted and cached
2. **During Implementation**: Standards are loaded with embedded verification blocks
3. **Post-Implementation**: verification-runner executes all applicable tests
4. **Compliance Reporting**: Results provide clear pass/fail status with fix suggestions

**Example Integration in create-spec.md (Step 11):**
```xml
<step number="11" subagent="verification-runner" name="extract_verification_plan">
### Step 11: Extract Verification Plan

<instructions>
  ACTION: Use verification-runner subagent  
  REQUEST: "Extract verification requirements from loaded standards and create verification plan"
  CACHE: Verification plan for later execution during implementation
</instructions>
</step>
```

### Advanced Verification Examples

The comprehensive architecture pattern files demonstrate sophisticated verification patterns for complex systems:

#### Billing System Verification (billing-patterns.md)
```xml
<verification-block context-check="billing-stripe-integration-verification">
  <verification_definitions>
    <test name="stripe_webhook_config">
      TEST: test -f packages/payments/provider/stripe/webhooks.ts
      REQUIRED: true
      ERROR: "Stripe webhook handlers missing. Create webhook configuration in packages/payments/provider/stripe/webhooks.ts"
      DESCRIPTION: "Validates Stripe webhook integration exists for subscription management"
    </test>
    <test name="billing_domain_separation">
      TEST: ! grep -r "stripe" packages/core/domain/ 2>/dev/null
      REQUIRED: true
      ERROR: "Direct Stripe usage found in domain layer. Use IPaymentGateway interface instead"
      DESCRIPTION: "Ensures billing domain layer remains framework-agnostic"
    </test>
    <test name="subscription_event_sourcing">
      TEST: test -f packages/core/domain/billing/events/SubscriptionChangedEvent.ts
      REQUIRED: true
      ERROR: "Subscription events missing. Implement event sourcing for billing changes"
      DESCRIPTION: "Validates event sourcing is implemented for subscription lifecycle"
    </test>
  </verification_definitions>
</verification-block>
```

#### Background Job Processing Verification (background-job-patterns.md)
```xml
<verification-block context-check="background-job-bullmq-verification">
  <verification_definitions>
    <test name="bullmq_queue_config">
      TEST: test -f packages/infrastructure/jobs/config/QueueConfig.ts
      REQUIRED: true
      ERROR: "BullMQ queue configuration missing. Create QueueConfig.ts with retry strategies"
      DESCRIPTION: "Validates BullMQ queue configuration exists with proper retry mechanisms"
    </test>
    <test name="domain_job_interface">
      TEST: test -f packages/core/domain/interfaces/IJobProcessor.ts
      REQUIRED: true
      ERROR: "Job processor interface missing in domain. Create IJobProcessor interface"
      DESCRIPTION: "Ensures job processing follows Clean Architecture with domain interfaces"
    </test>
    <test name="job_step_recovery">
      TEST: grep -q "StepRecoveryStrategy" packages/infrastructure/jobs/processors/
      REQUIRED: true
      ERROR: "Step recovery not implemented. Add StepRecoveryStrategy to job processors"
      DESCRIPTION: "Validates step-based job processing with recovery mechanisms"
    </test>
  </verification_definitions>
</verification-block>
```

#### Search System Verification (search-patterns.md)
```xml
<verification-block context-check="search-elasticsearch-verification">
  <verification_definitions>
    <test name="elasticsearch_client_abstraction">
      TEST: test -f packages/core/domain/interfaces/ISearchService.ts
      REQUIRED: true
      ERROR: "Search service interface missing. Create ISearchService for domain layer abstraction"
      DESCRIPTION: "Validates Elasticsearch is properly abstracted behind domain interface"
    </test>
    <test name="search_indexing_jobs">
      TEST: test -f packages/infrastructure/jobs/processors/SearchIndexingProcessor.ts
      REQUIRED: true
      ERROR: "Search indexing jobs missing. Create background processors for search indexing"
      DESCRIPTION: "Ensures search indexing is handled via background job processing"
    </test>
    <test name="faceted_search_implementation">
      TEST: grep -q "FacetedSearchQuery" packages/core/domain/search/
      REQUIRED: true
      ERROR: "Faceted search domain model missing. Implement FacetedSearchQuery value object"
      DESCRIPTION: "Validates faceted search capabilities with proper domain modeling"
    </test>
  </verification_definitions>
</verification-block>
```

#### Multi-Level Caching Verification (caching-patterns.md)
```xml
<verification-block context-check="caching-redis-multilevel-verification">
  <verification_definitions>
    <test name="cache_service_interface">
      TEST: test -f packages/core/domain/interfaces/ICacheService.ts
      REQUIRED: true
      ERROR: "Cache service interface missing. Create ICacheService for domain abstraction"
      DESCRIPTION: "Validates caching is properly abstracted in domain layer"
    </test>
    <test name="redis_configuration">
      TEST: test -f packages/infrastructure/cache/RedisConfig.ts
      REQUIRED: true
      ERROR: "Redis configuration missing. Create RedisConfig.ts with cluster support"
      DESCRIPTION: "Ensures Redis is properly configured for production deployment"
    </test>
    <test name="multilevel_cache_strategy">
      TEST: grep -q "MultiLevelCacheService" packages/infrastructure/cache/
      REQUIRED: true
      ERROR: "Multi-level caching not implemented. Create MultiLevelCacheService with L1/L2 strategy"
      DESCRIPTION: "Validates multi-level caching implementation (memory + Redis)"
    </test>
    <test name="cache_invalidation_events">
      TEST: grep -q "CacheInvalidationEvent" packages/core/domain/events/
      REQUIRED: true
      ERROR: "Cache invalidation events missing. Implement event-driven cache invalidation"
      DESCRIPTION: "Ensures cache invalidation follows event sourcing patterns"
    </test>
  </verification_definitions>
</verification-block>
```

#### Notification System Verification (notification-patterns.md)
```xml
<verification-block context-check="notification-multichannel-verification">
  <verification_definitions>
    <test name="notification_service_interface">
      TEST: test -f packages/core/domain/interfaces/INotificationService.ts
      REQUIRED: true
      ERROR: "Notification service interface missing. Create INotificationService for domain abstraction"
      DESCRIPTION: "Validates notification system follows Clean Architecture patterns"
    </test>
    <test name="email_channel_implementation">
      TEST: test -f packages/infrastructure/notifications/channels/EmailChannel.ts
      REQUIRED: true
      ERROR: "Email channel missing. Implement EmailChannel with Nodemailer integration"
      DESCRIPTION: "Ensures email notifications are implemented with proper SMTP configuration"
    </test>
    <test name="notification_templates">
      TEST: test -d packages/infrastructure/notifications/templates/
      REQUIRED: true
      ERROR: "Notification templates directory missing. Create template system for multi-channel notifications"
      DESCRIPTION: "Validates template-based notification system exists"
    </test>
    <test name="user_preferences_integration">
      TEST: grep -q "NotificationPreferences" packages/core/domain/user/
      REQUIRED: true
      ERROR: "User notification preferences missing. Implement NotificationPreferences value object"
      DESCRIPTION: "Ensures users can configure notification channel preferences"
    </test>
  </verification_definitions>
</verification-block>
```

#### Audit Logging & Compliance Verification (audit-logging-patterns.md)
```xml
<verification-block context-check="audit-logging-compliance-verification">
  <verification_definitions>
    <test name="audit_entry_immutable">
      TEST: grep -q "readonly" packages/core/domain/audit/AuditEntry.ts
      REQUIRED: true
      ERROR: "Audit entries not immutable. Implement readonly properties for compliance requirements"
      DESCRIPTION: "Validates audit entries follow immutability principle for compliance"
    </test>
    <test name="event_sourcing_store">
      TEST: test -f packages/infrastructure/audit/EventSourcingStore.ts
      REQUIRED: true
      ERROR: "Event sourcing store missing. Create EventSourcingStore for immutable audit trail"
      DESCRIPTION: "Ensures audit logging uses event sourcing for complete traceability"
    </test>
    <test name="compliance_retention_policy">
      TEST: grep -q "RetentionPolicy" packages/infrastructure/audit/
      REQUIRED: true
      ERROR: "Retention policy not implemented. Add RetentionPolicy for GDPR/SOX compliance"
      DESCRIPTION: "Validates automatic retention policies for regulatory compliance"
    </test>
    <test name="risk_classification">
      TEST: grep -q "AuditRiskLevel" packages/core/domain/audit/
      REQUIRED: true
      ERROR: "Risk classification missing. Implement AuditRiskLevel for security monitoring"
      DESCRIPTION: "Ensures audit events are classified by risk level for security analysis"
    </test>
    <test name="forensic_query_interface">
      TEST: test -f packages/core/domain/interfaces/IForensicQueryService.ts
      REQUIRED: true
      ERROR: "Forensic query interface missing. Create IForensicQueryService for investigation capabilities"
      DESCRIPTION: "Validates forensic investigation capabilities are properly abstracted"
    </test>
  </verification_definitions>
</verification-block>
```

These comprehensive verification examples demonstrate:

1. **System Integration Verification**: Ensuring proper integration between domain and infrastructure layers
2. **Compliance-Driven Verification**: Validating regulatory requirements (GDPR, SOX, PCI-DSS) are met
3. **Architecture Purity Verification**: Confirming Clean Architecture principles are maintained across complex systems
4. **Performance Pattern Verification**: Ensuring multi-level caching, background processing, and search optimization are properly implemented
5. **Security-First Verification**: Validating security measures in billing, audit logging, and notification systems

Each verification block combines multiple test types:
- **File Existence Tests**: Ensuring required components are implemented
- **Content Validation Tests**: Verifying specific patterns and configurations exist
- **Architecture Compliance Tests**: Confirming Clean Architecture principles are followed
- **Integration Tests**: Validating proper service boundaries and interfaces
- **Security Tests**: Ensuring sensitive operations follow security best practices

## Troubleshooting

### Common Standards DSL Issues

#### Keywords Not Matching

**Problem**: Conditional blocks not triggering
**Solution**: Check if keywords align with how tasks are described

```xml
<!-- Before: Too specific -->
task-condition="handleApiValidation"

<!-- After: More flexible -->
task-condition="api|validation|server-action|endpoint"
```

#### Circular References

**Problem**: Dispatchers routing to themselves or creating loops
**Solution**: Audit routing paths and ensure linear progression

```
✗ standards.md → security.md → standards.md
✓ standards.md → security.md → api-security.md
```

#### Context Window Overflow

**Problem**: Too much content loaded at once
**Solution**: Use more granular conditional blocks

```xml
<!-- Before: Loads everything -->
<conditional-block task-condition="api">
  REQUEST: "Load all API standards"
</conditional-block>

<!-- After: Specific loading -->
<conditional-block task-condition="api|validation" context-check="api-validation">
IF task involves API validation:
  REQUEST: "Get API validation patterns from security/api-security.md#validation"
</conditional-block>
```

### Common Instructions DSL Issues

#### Step Dependencies

**Problem**: Later steps fail because earlier steps didn't complete properly
**Solution**: Add validation and state checking

```xml
<step number="2" name="dependent_step">
### Step 2: Dependent Operation

<prerequisites>
  VERIFY: Step 1 completed successfully
  CHECK: Required resources available
  VALIDATE: Input parameters correct
</prerequisites>

<instructions>
  ACTION: Perform dependent operation
</instructions>
</step>
```

#### Subagent Communication

**Problem**: Subagents not receiving clear instructions
**Solution**: Structure requests with specific parameters

```xml
<!-- Before: Vague request -->
<instructions>
  REQUEST: "Get some documentation"
</instructions>

<!-- After: Specific request -->
<instructions>
  REQUEST: "Get API documentation from docs/api-spec.md including authentication and rate limiting sections"
</instructions>
```

## Migration Guide

### Updating Existing Standards

#### Adding Hierarchical Support

If you have standalone standards files, integrate them into the hierarchy:

1. **Identify Category**: Determine which category your standard belongs to
2. **Add Conditional Blocks**: Wrap content in appropriate conditional blocks
3. **Update Dispatcher**: Add routing logic to category dispatcher
4. **Test Routing**: Verify the routing path works correctly

#### Converting Direct References

Replace direct file references with hierarchical routing:

```xml
<!-- Before: Direct reference -->
REQUEST: "Get patterns from code-style/typescript-style.md"

<!-- After: Hierarchical routing -->
REQUEST: "Consult the standards knowledge base for TypeScript guidance. Start at @docs/standards/standards.md and follow the routing logic."
```

### Updating Existing Commands

#### Adding Standards Integration

Add standards consultation to existing workflows:

```xml
<step number="1.5" subagent="context-fetcher" name="consult_standards">
### Step 1.5: Standards Consultation

<instructions>
  ACTION: Use context-fetcher subagent
  REQUEST: "Consult standards for guidance on current task"
  APPLY: Retrieved patterns to workflow
</instructions>
</step>
```

## Performance Guidelines

### Optimization Targets

- **Dispatcher Routing**: <100ms per hop
- **Standard Loading**: <500ms per file
- **Context Checking**: <50ms
- **Total Initialization**: <2s for complex workflows

### Monitoring Usage

Track these metrics to optimize performance:

1. **Most Accessed Standards**: Focus optimization here
2. **Routing Path Length**: Keep under 3 hops
3. **Context Window Usage**: Standards should use <10%
4. **Loading Failures**: Identify and fix broken paths

This guide provides the practical knowledge needed to effectively work with the Engineering OS DSL system. Follow these patterns and best practices to create maintainable, efficient standards and commands that scale with your project's growth.
