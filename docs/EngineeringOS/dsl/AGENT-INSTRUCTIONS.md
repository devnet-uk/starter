# AGENT INSTRUCTIONS - Engineering OS DSL System

## PURPOSE

You are working with a Domain-Specific Language (DSL) system designed to optimize your operations. Your primary mode of interaction is **navigation, not searching**. You will start at a root "dispatcher" file and follow a structured path to the precise context you need. This avoids context window waste and ensures you always have the correct guidance.

## SYSTEM ARCHITECTURE

### Two-DSL Model

You will encounter two complementary DSLs:

#### 1. Standards DSL (Knowledge Base)
- **Location**: `/docs/standards/`
- **Entry Point**: `/docs/standards/standards.md` (root dispatcher)
- **Purpose**: Provide context-relevant guidance without overloading context window
- **Architecture**: Hierarchical routing (Root → Category → Standard)

#### 2. Instructions DSL (Workflow Automation)  
- **Location**: `.claude/commands/`
- **Purpose**: Define repeatable, structured workflows with decision trees
- **Architecture**: Sequential steps with subagent delegation

### Hierarchical Dispatcher Model

The Standards DSL uses a three-tier hierarchy:

```
Root Dispatcher (standards.md)
├── Category Dispatchers (architecture/architecture.md)
│   └── Standard Files (architecture/clean-architecture.md)
├── Category Dispatchers (security/security.md)  
│   └── Standard Files (security/api-security.md)
└── [Additional categories...]
```

#### Standards Dependency Graph

The following graph visualizes the dependency hierarchy of the standards, starting from the root dispatcher. This is generated by analyzing the routing within the files themselves.

```
/docs/standards/standards.md
├── /docs/standards/architecture/architecture.md
│   ├── /docs/standards/architecture/clean-architecture.md
│   │   ├── /docs/standards/architecture/domain-utilities.md
│   │   ├── /docs/standards/architecture/infrastructure-patterns.md
│   │   └── /docs/standards/architecture/integration-strategy.md
│   ├── /docs/standards/architecture/domain-driven-design.md
│   ├── /docs/standards/architecture/feature-sliced-design.md
│   │   └── /docs/standards/architecture/integration-strategy.md
│   ├── /docs/standards/architecture/solid-principles.md
│   ├── /docs/standards/architecture/resilience-patterns.md
│   ├── /docs/standards/architecture/integration-strategy.md
│   ├── /docs/standards/architecture/agent-standards-integration.md
│   ├── /docs/standards/architecture/refactoring-patterns.md
│   ├── /docs/standards/architecture/use-case-patterns.md
│   ├── /docs/standards/architecture/multi-tenancy-patterns.md
│   ├── /docs/standards/architecture/streaming-patterns.md
│   ├── /docs/standards/architecture/billing-patterns.md
│   ├── /docs/standards/architecture/background-job-patterns.md
│   ├── /docs/standards/architecture/notification-patterns.md
│   ├── /docs/standards/architecture/search-patterns.md
│   ├── /docs/standards/architecture/caching-patterns.md
│   └── /docs/standards/architecture/audit-logging-patterns.md
├── /docs/standards/code-style.md
│   ├── /docs/standards/code-style/typescript-style.md
│   │   └── /docs/standards/development/monorepo-setup.md
│   ├── /docs/standards/code-style/naming-conventions.md
│   │   └── /docs/standards/stack-specific/drizzle-patterns.md
│   ├── /docs/standards/code-style/react-patterns.md
│   ├── /docs/standards/code-style/css-style.md
│   └── /docs/standards/code-style/html-style.md
├── /docs/standards/performance/performance.md
│   ├── /docs/standards/performance/bundle-optimization.md
│   ├── /docs/standards/performance/core-web-vitals.md
│   └── /docs/standards/performance/observability.md
│       └── /docs/standards/development/local-environment.md
├── /docs/standards/security/security.md
│   ├── /docs/standards/security/api-security.md
│   ├── /docs/standards/security/authentication.md
│   ├── /docs/standards/security/authentication-patterns.md
│   └── /docs/standards/security/dependency-scanning.md
├── /docs/standards/development/development.md
│   ├── /docs/standards/development/ci-cd.md
│   │   └── /docs/standards/development/testing-strategy.md
│   ├── /docs/standards/development/code-review.md
│   ├── /docs/standards/development/database-migrations.md
│   ├── /docs/standards/development/documentation.md
│   ├── /docs/standards/development/git-workflow.md
│   │   └── /docs/standards/development/local-quality.md
│   ├── /docs/standards/development/testing-strategy.md
│   ├── /docs/standards/development/monorepo-setup.md
│   │   └── /docs/standards/code-style/typescript-style.md
│   ├── /docs/standards/development/local-environment.md
│   ├── /docs/standards/development/local-quality.md
│   │   └── /docs/standards/development/metrics.md
│   └── /docs/standards/development/metrics.md
├── /docs/standards/stack-specific/stack-specific.md
│   ├── /docs/standards/stack-specific/drizzle-patterns.md
│   ├── /docs/standards/stack-specific/hono-api.md
│   ├── /docs/standards/stack-specific/next-safe-action.md
│   ├── /docs/standards/stack-specific/tanstack-query.md
│   ├── /docs/standards/stack-specific/vercel-ai.md
│   ├── /docs/standards/stack-specific/vercel-deployment.md
│   └── /docs/standards/stack-specific/zustand-state.md
└── /docs/standards/best-practices.md
    ├── /docs/standards/architecture/resilience-patterns.md
    ├── /docs/standards/architecture/clean-architecture.md
    ├── /docs/standards/architecture/feature-sliced-design.md
    ├── /docs/standards/architecture/domain-driven-design.md
    ├── /docs/standards/architecture/solid-principles.md
    ├── /docs/standards/development/git-workflow.md
    ├── /docs/standards/development/testing-strategy.md
    ├── /docs/standards/stack-specific/hono-api.md
    ├── /docs/standards/security/api-security.md
    ├── /docs/standards/stack-specific/drizzle-patterns.md
    ├── /docs/standards/development/database-migrations.md
    ├── /docs/standards/stack-specific/zustand-state.md
    ├── /docs/standards/performance/core-web-vitals.md
    ├── /docs/standards/performance/bundle-optimization.md
    ├── /docs/standards/security/authentication.md
    ├── /docs/standards/stack-specific/next-safe-action.md
    ├── /docs/standards/security/server-actions.md
    ├── /docs/standards/development/ci-cd.md
    ├── /docs/standards/stack-specific/vercel-deployment.md
    ├── /docs/standards/performance/monitoring.md
    ├── /docs/standards/stack-specific/vercel-ai.md
    ├── /docs/standards/development/code-review.md
    ├── /docs/standards/development/documentation.md
    ├── /docs/standards/security/dependency-scanning.md
    └── /docs/standards/stack-specific/tanstack-query.md
```

**Critical Rule**: ALWAYS start at the root dispatcher unless directly accessing a specific standard file. Never bypass the hierarchy.

## Core Workflows & Context Layers

The Instructions DSL orchestrates a set of core workflows, each corresponding to a layer of context required for intelligent operation. These are the primary entry points for agents.

1.  **The Standards Layer**: Establishing the foundation.
    *   This layer is managed by the **Standards DSL** itself (`/docs/standards`). It defines the rules of engagement for any project.

2.  **The Product Layer**: Defining the "what" and "why."
    *   **`plan-product`**: Establishes the product context (mission, roadmap, tech stack).
    *   **`analyze-product`**: Builds the product context by analyzing an existing codebase.

3.  **The Specs Layer**: Defining the "how" for a specific feature.
    *   **`create-spec`**: Creates a new feature specification (the plan).
    *   **`create-tasks`**: Translates the spec into a detailed, executable task list.
    *   **`execute-tasks`**: Implements the tasks defined in the spec, consuming all three layers of context to produce compliant code.

## KEY CONCEPTS FOR AGENTS

### Understanding Conditional Blocks

The core construct for dynamic content loading:

```xml
<conditional-block task-condition="keywords|separated|by|pipes" context-check="example-unique-id-agents">
  <context_fetcher_strategy>
    USE: @agent:context-fetcher
    REQUEST: "Specific request for content"
  </context_fetcher_strategy>
</conditional-block>
```

**When you encounter this:**
1. Check if current task matches any keyword in `task-condition`
2. Check if `context-check` content is already loaded
3. If both conditions met, execute the fetcher strategy
4. Otherwise, skip this block

### Processing Standards Files

**Your core workflow is to navigate the standards hierarchy.**

**Always:**
- Start at the root dispatcher: `/docs/standards/standards.md`.
- Analyze the user's task to determine the *intent* (e.g., "testing", "api-security", "database-migration").
- Match this intent to the `task-condition` keywords in the current dispatcher file.
- Follow the routing instruction in the matching `<context_fetcher_strategy>` to the next level (either another dispatcher or a final standard).
- Cache the content you load to avoid re-fetching. The `context-check` ID helps you track what's already in your context.

### Processing Verification Blocks

Standards may contain `<verification-block>` definitions for automated compliance checking. These are not routed to but are **extracted at runtime** by the `verification-runner` subagent from the standards you have already loaded into your context.

**Your Workflow:**
1.  **Load Standards**: Use the hierarchical dispatcher (`standards.md`) to load standards relevant to your task.
2.  **Cache Verifications**: As you load standards, recognize and cache any `<verification-block>` definitions you encounter.
3.  **Delegate Execution**: When a workflow step requires validation (e.g., post-implementation), delegate to the `verification-runner` subagent.
4.  **Provide Context**: The `verification-runner` will use the cached verification definitions and apply project-specific variables to them.
5.  **Process Results**: Receive a pass/fail status and actionable error messages for any failures.

Note (authoring docs for humans): Verification authoring guidance and schema live under `docs/EngineeringOS/dsl/verification/` (authoring-guide.md, profiles.md, variable-extraction-utilities.md, schema.yaml, examples/). These are not routed via the standards dispatcher and are not loaded at runtime by agents.

### Verification Mode Governance
- Default mode: `blocking` — BLOCKING=true failures halt execution; tasks cannot be marked complete until fixed.
- Advisory mode: `advisory` — Allowed only with explicit user approval; report failures and require a user decision to proceed (must log decision).
- How to set: pass `VERIFICATION_MODE=blocking|advisory` in session/environment; commands default to `blocking` if unset.

### Network Operations Policy
- Networked installs or fetches are disallowed by default in commands.
- Exception: a command may prompt the user to install optional tools (e.g., refactor-codebase). If declined, the command must continue with a clear non-network fallback path and reduced capabilities.

### Profiles and Variables (Greenfield, Standard, Legacy)

- Set or infer profile variables in command contexts:
  - `PROJECT_TYPE` (e.g., greenfield), `PROJECT_COVERAGE` (e.g., 98), `NODE_VERSION` (e.g., 22), `PORT_WEB`, `PORT_API`.
- Expect tests gated by `PROJECT_TYPE` (e.g., pre-push/devcontainer/reporters required only for greenfield).
- Verification Mode (default blocking): `/execute-tasks` runs verification-runner in blocking mode by default (halts on BLOCKING=true failures). Advisory mode may be used only with explicit governance; in advisory, report failures and require a user decision to proceed.

**Example Delegation to `verification-runner`:**
```xml
<step number="8" subagent="verification-runner" name="verify_compliance">
  <instructions>
    ACTION: Use verification-runner subagent
    REQUEST: "Execute all verification tests from loaded standards against the current implementation."
    PROCESS: Verification results and compliance status.
  </instructions>
</step>
```

### Variable Substitution

Verification tests are dynamic. They use placeholders that the `verification-runner` will substitute with values it detects from the project's context. Your role is to be aware of these variables when interpreting test results or error messages.

**Key Variables:**
-   **`${PROJECT_TYPE}`**: The project's detected type (e.g., "greenfield", "standard", "legacy"). This affects which rules are applied strictly.
-   **`${PROJECT_COVERAGE}`**: The required test coverage percentage (e.g., "98").
-   **`${PROJECT_NAME}`**: The name of the project.
-   **`${GIT_HOOKS}`**: A list of required git hooks (e.g., "pre-commit commit-msg").
-   **`${PROJECT_PHASES}`**: A boolean (`true`|`false`) indicating if the project uses a formal phased development plan.

### Processing Instruction Files

**When you see an instruction file:**

```xml
<process_flow>
  <step number="1" name="step_name">
    <instructions>
      ACTION: What to do
    </instructions>
  </step>
</process_flow>
```

**Always:**
- Execute steps in numerical order
- Delegate to subagents when specified
- Follow action keywords (ACTION, REQUEST, EXECUTE, etc.)
- Run pre/post flight checks as bookends

## OPTIMIZATION STRATEGIES

### 1. Context Window Management

**Do:**
- Use conditional blocks to filter content
- Check for already-loaded content via context-check
- Load specific sections when possible
- Cache standards within session

**Don't:**
- Load entire file hierarchies
- Bypass conditional filtering
- Reload content already in context
- Ignore context window limits

### 2. Efficient Routing

**Standards Loading Pattern:**
```
Task: "Create React component with TypeScript"
↓
1. standards.md (root) → matches "react|typescript"
↓  
2. code-style.md (category) → routes to react-patterns.md
↓
3. react-patterns.md (standard) → loads React guidance
```

**Critical Rules:**
- Maximum 3 hops from root to content
- Use most specific keywords possible
- Follow dispatcher chain, don't skip levels
- Root dispatchers contain no content, only routing

### 3. Stateless Operations

**Remember:**
- Each agent invocation starts fresh
- Standards are cached per session only
- No persistent state between agent calls
- Context checking prevents duplicate loading

## INTERACTION PATTERNS

### Reading Standards (Correct Pattern)

```
Step 1: Start at root dispatcher
LOAD: /docs/standards/standards.md

Step 2: Match task conditions  
IF task involves "api|security":
  FOLLOW route to security/security.md

Step 3: Follow category routing
IF task involves "api-security":
  FOLLOW route to security/api-security.md
  
Step 4: Extract relevant content
LOAD: Only sections matching current task
```

### Reading Standards (Incorrect Pattern - Don't Do This)

```
❌ LOAD: /docs/standards/security/api-security.md directly
❌ LOAD: All security standards regardless of task
❌ IGNORE conditional blocks and load everything  
❌ SKIP context checking and reload cached content
```

### Executing Instructions

```
Step 1: Load instruction file
READ: .claude/commands/execute-tasks.md

Step 2: Execute pre-flight check
EXECUTE: @.claude/commands/meta/pre-flight.md

Step 3: Process workflow steps sequentially
FOR each step in process_flow:
  IF step has subagent:
    DELEGATE to specified subagent
  ELSE:
    EXECUTE step instructions directly

Step 4: Execute post-flight check
EXECUTE: @.claude/commands/meta/post-flight.md
```

## CRITICAL RULES

### Standards DSL Rules

1. **NEVER modify DSL syntax** in any files
2. **ALWAYS start at root dispatcher** (`/docs/standards/standards.md`)
3. **RESPECT conditional blocks** - only load when conditions match
4. **USE context-fetcher agent** for standards retrieval
5. **MAINTAIN hierarchical routing** - don't bypass dispatchers
6. **PRESERVE routing vs content separation** - dispatchers route, standards contain content

### Instructions DSL Rules

1. **FOLLOW step numbers sequentially** - execute in order
2. **DELEGATE when specified** - use subagents as directed
3. **EXECUTE flight checks** - run pre/post operations
4. **RESPECT action keywords** - ACTION, REQUEST, EXECUTE have specific meanings
5. **HANDLE errors gracefully** - include fallback logic
6. **MAINTAIN workflow state** - track progress through steps

### Performance Rules

1. **Context window efficiency** - standards should use <10% of context
2. **Routing speed** - dispatcher hops should complete in <100ms each
3. **Loading time** - individual files should load in <500ms
4. **Total initialization** - complex workflows should start in <2s
5. **Memory management** - avoid loading duplicate or unnecessary content

## SUBAGENT COORDINATION

### Available Subagents

- **context-fetcher**: Targeted information retrieval from standards
- **git-workflow**: Git operations and branch management  
- **file-creator**: File and directory creation with templates
- **test-runner**: Test execution and failure analysis
- **project-manager**: Task tracking and documentation updates
- **verification-runner**: Extract and execute verification tests from loaded standards to ensure compliance

### Delegation Pattern

```xml
<step number="2" subagent="context-fetcher" name="load_standards">
  <instructions>
    ACTION: Use context-fetcher subagent
    REQUEST: "Consult the standards knowledge base for guidance relevant to the current task. Start at the root dispatcher located at @docs/standards/standards.md and follow the routing logic to retrieve the necessary guidance."
    WAIT: For retrieval completion
    PROCESS: Returned guidance
  </instructions>
</step>

<step number="8" subagent="verification-runner" name="verify_compliance">
  <instructions>
    ACTION: Use verification-runner subagent
    REQUEST: "Execute all verification tests from loaded standards against current implementation"
    WAIT: For verification completion
    PROCESS: Verification results and compliance status
  </instructions>
</step>
```

**When delegating:**
- Provide clear, specific requests
- Wait for subagent completion
- Process returned information
- Don't assume subagents maintain state

## ERROR HANDLING

### Standards DSL Errors

**Dispatcher routing fails:**
- Report specific routing path attempted
- Try alternative keywords if available
- Use conservative defaults if all routing fails
- Continue with workflow, warn user of missing guidance

**Conditional block has no match:**
- Skip section, continue processing
- Don't load irrelevant content
- Log skipped sections for debugging

**Standard file not found:**
- Report missing file path
- Use fallback guidance if available
- Warn user about potential inconsistencies

### Instructions DSL Errors

**Step execution fails:**
- Report specific step and error
- Attempt graceful recovery if possible
- If no recovery possible, abort workflow safely
- Provide clear error message to user

**Subagent unavailable:**
- Attempt direct execution if possible
- Warn user about degraded functionality
- Continue with reduced capabilities
- Document what couldn't be completed

**Resource unavailable:**
- Check for alternative resources
- Use cached information if available
- Graceful degradation to simpler approach
- Clear user communication about limitations

## PERFORMANCE EXPECTATIONS

### Target Metrics

- **Dispatcher routing**: <100ms per hop
- **Standard loading**: <500ms per file
- **Context check**: <50ms
- **Total initialization**: <2s for complex tasks
- **Context usage**: Standards <10% of context window
- **Memory efficiency**: No duplicate content loading

### Monitoring Your Performance

Track these metrics as you work:
1. How many routing hops to reach content?
2. How much context window used for standards?
3. Any duplicate content loaded?
4. Response time from routing to content delivery?
5. How often do conditional blocks trigger?

### Optimization Techniques

1. **Batch related requests** when possible
2. **Use specific keywords** in task conditions
3. **Check context before loading** every time
4. **Load minimal necessary content** only
5. **Cache effectively within session**

## INTEGRATION BEST PRACTICES

### Standards Integration in Workflows

Most instruction workflows should include standards consultation:

```xml
<step number="N" subagent="context-fetcher" name="consult_standards">
### Step N: Standards Consultation

<instructions>
  ACTION: Use context-fetcher subagent
  REQUEST: "Consult the standards knowledge base for guidance relevant to the current task. Start at the root dispatcher located at @docs/standards/standards.md and follow the routing logic to retrieve the necessary guidance."
  PROCESS: Returned standards and guidance
  APPLY: Relevant patterns to implementation
</instructions>
</step>
```

### Context Preservation

- **Cache standards** within your session
- **Reuse loaded content** for related tasks
- **Don't reload** what's already available
- **Share context** between workflow steps

### Efficient Task Analysis

Before loading standards, analyze the task for keywords:
- Technology stack (React, TypeScript, Drizzle, etc.)
- Activity type (testing, deployment, security, etc.)
- Architecture patterns (clean, microservices, etc.)
- File types (.ts, .tsx, .test.js, etc.)

Use this analysis to predict which standards you'll need.

## SUCCESS CRITERIA

You're using the DSL system correctly when:

1. ✅ **Routing efficiency**: 2-3 hops maximum from root to content
2. ✅ **Context management**: <10% context window usage for standards
3. ✅ **No duplication**: Content loaded once per session
4. ✅ **Conditional respect**: Only loading content when conditions match
5. ✅ **Proper delegation**: Using subagents for their specialized capabilities
6. ✅ **Workflow completion**: Following instruction steps to completion
7. ✅ **Error handling**: Graceful degradation when things go wrong
8. ✅ **Performance targets**: Meeting speed and efficiency metrics

## COMMON MISTAKES TO AVOID

### Don't Do This:
- ❌ **Searching the filesystem**: Do not use `grep` or file search tools on the `/docs/standards/` directory. This bypasses the entire optimized routing system and will lead to incorrect or incomplete context.
- ❌ **Loading files directly**: Do not load a standard file (e.g., `api-security.md`) directly unless you have been explicitly routed to it by a dispatcher. You will miss the broader context.
- ❌ **Ignoring `task-condition`**: Do not load all blocks in a file. Only process the blocks whose `task-condition` matches your current task's intent.
- ❌ Load standards directly without using root dispatcher
- ❌ Ignore conditional blocks and load everything
- ❌ Reload content that's already in context
- ❌ Skip step numbers or execute out of order
- ❌ Bypass subagent delegation when specified
- ❌ Modify DSL syntax in files
- ❌ Create circular routing references
- ❌ Load unrelated standards for current task

### Do This Instead:
- ✅ Always start at root dispatcher for standards
- ✅ Respect conditional blocks and task conditions
- ✅ Check context before loading new content
- ✅ Execute instruction steps sequentially
- ✅ Use subagents as specified in workflows
- ✅ Preserve DSL structure in all files
- ✅ Maintain linear routing progression
- ✅ Load only task-relevant standards

## PRACTICAL EXAMPLES FOR AGENTS

### Example 1: Standards Chain Loading

For complex tasks requiring multiple standards:

```
Task: "Create secure API with authentication"

1. Root Dispatcher (standards.md)
   Matches: "api|security|authentication"
   Routes to: security/security.md

2. Security Category Dispatcher
   Multiple matches:
   - "api" → routes to api-security.md
   - "authentication" → routes to authentication.md

3. Load both standards:
   - API security patterns (rate limiting, validation)
   - Authentication patterns (JWT, sessions)
```

### Example 2: Efficient Conditional Loading

```xml
<!-- Efficient: Load specific content -->
<conditional-block task-condition="typescript|interface" context-check="typescript-interfaces">
IF task only involves TypeScript interfaces:
  <context_fetcher_strategy>
    REQUEST: "Get interface patterns from code-style/typescript-style.md#interfaces"
  </context_fetcher_strategy>
</conditional-block>

<!-- Inefficient: Avoid loading everything -->
<conditional-block task-condition="typescript" context-check="all-typescript">
  REQUEST: "Load all TypeScript guidance including everything"
</conditional-block>
```

### Example 3: Command with Dynamic Standards

```xml
<step number="2" subagent="context-fetcher" name="dynamic_standards">
### Step 2: Dynamic Standards Loading

<standards_detection>
  ANALYZE task for:
    - File extensions (.ts, .tsx, .test.js)
    - Technology mentions (React, API, database)
    - Activity types (testing, security)
</standards_detection>

<dynamic_loading>
  IF ".tsx" AND "component" mentioned:
    REQUEST: "Get React patterns from code-style/react-patterns.md"
  IF "test" OR ".test.js" in requirements:
    REQUEST: "Get testing strategy from development/testing-strategy.md"
  IF "api" OR "endpoint" mentioned:
    REQUEST: "Get API security from security/api-security.md"
</dynamic_loading>
</step>
```

### Example 4: Error Handling Pattern

```xml
<step number="3" name="robust_execution">
### Step 3: Execution with Fallbacks

<error_handling>
  <missing_standards>
    IF standard file unavailable:
      WARN: "Missing guidance for [area]"
      FALLBACK: Use conservative defaults
      CONTINUE: With reduced capabilities
  </missing_standards>
  
  <routing_failure>
    IF dispatcher routing fails:
      REPORT: Specific path attempted
      TRY: Alternative keywords
      CONTINUE: With best available guidance
  </routing_failure>
</error_handling>
</step>
```

### Example 5: Performance-Optimized Caching

```xml
<step number="1" name="smart_caching">
### Step 1: Intelligent Standards Caching

<caching_strategy>
  CHECK: Session context for loaded standards
  IF typescript-patterns already loaded:
    SKIP: Re-loading TypeScript patterns
    NOTE: "Using cached TypeScript patterns"
  ELSE:
    LOAD: Required TypeScript patterns only
    CACHE: For session duration
    MONITOR: Context window usage (<10%)
</caching_strategy>
</step>
```

### Example 6: Context-Aware Task Analysis

```
Before loading ANY standards, analyze:

Task: "Fix authentication bug in React component"
Keywords detected: authentication, react, component, bug, fix

Standards to load:
✓ security/authentication.md (authentication)
✓ code-style/react-patterns.md (react, component)
✓ development/debugging.md (bug, fix)

Skip these (not relevant):
✗ database patterns
✗ deployment guides
✗ CSS styling
```

## SUMMARY

The Engineering OS DSL system optimizes LLM operations through hierarchical knowledge organization and structured workflows. By following these patterns and rules, you'll achieve efficient, maintainable operations that scale with system complexity while preserving performance and context efficiency.

**Remember the core principle**: Load only what you need, when you need it, through the proper channels.

**Key Agent Behaviors:**
1. Always start at root dispatcher (`@docs/standards/standards.md`)
2. Use task analysis to predict required standards
3. Check context before loading to avoid duplication
4. Cache loaded standards within session
5. Monitor performance metrics continuously
6. Handle errors gracefully with fallbacks
